//
// Several functions for generating Swift code based on the parsed AST.
//

var ast = require('./SwiftAst')

function makeFile(file: any[], aliases: TypeAliases, filename: string) {
  var lines = [];

  lines.push('//');
  lines.push('//  ' + filename);
  lines.push('//');
  lines.push('//  Auto generated by swift-json-gen on ' + new Date().toUTCString());
  lines.push('//');
  lines.push('');
  lines.push('import Foundation');
  lines.push('');

  var structs = ast.structs(file, aliases);
  structs.forEach(function (s) {
    lines = lines.concat(makeExtension(s, aliases));
    lines.push('');
  });

  return lines;
}

exports.makeFile = makeFile;

function makeExtension(struct: Struct, aliases: TypeAliases) {
  var pre = [
    'extension ' + struct.baseName + ' {',
    '  static func decode(json : AnyObject) -> ' + struct.baseName + '? {',
    '    let _dict = json as? [String : AnyObject]',
    '    if _dict == nil { return nil }',
    '    let dict = _dict!',
    '',
  ];
  var post = [
    '  }',
    '}'
  ];

  var lines = pre;

  struct.varDecls.forEach(function (d) {
    var subs = makeField(d, aliases).map(indent(4));
    lines = lines.concat(subs);
  });

  lines = lines.concat(indent(4)(makeReturn(struct)));
  lines = lines.concat(post);

  return lines.join('\n');
}
function indent(nr) {
  return function (s) {
    return s == '' ? s :  Array(nr + 1).join(' ') + s;
  };
}

function isKnownType(type: string) : boolean {
  return type == 'AnyObject' || type == 'AnyJson';
}

function isCastType(type: string) : boolean {
  return type == 'JsonObject' || type == 'JsonArray';
}

function decodeFunction(type: Type) : string {
  var args = type.genericArguments.map(t => '({ ' + decodeFunction(t) + '($0) })')
  return type.baseName + '.decode' + args;
}

function typeToString(type: Type) : string {
  if (type.genericArguments.length == 0)
    return type.baseName;

  if (type.baseName == 'Optional')
    return typeToString(type.genericArguments[0]) + '?';

  if (type.baseName == 'Array')
    return '[' + typeToString(type.genericArguments[0]) + ']';

  if (type.baseName == 'Dictionary')
    return '[' + typeToString(type.genericArguments[0]) + ' : ' + typeToString(type.genericArguments[1]) + ']';

  var args = type.genericArguments.map(typeToString).join(', ')
  return type.baseName + '<' + args + '>';
}

function makeField(field: VarDecl, aliases: TypeAliases) {
  var name = field.name;
  var type = field.type;
  var fieldName = name + '_field';
  var valueName = name + '_value';
  var typeString = typeToString(type);

  var lines = [
    'let ' + fieldName + ': AnyObject? = dict["' + name + '"]',
  ];

  if (type.baseName == 'Optional') {
    lines.push('let ' + name + ': ' + typeString + ' = ' + fieldName + ' == nil ? nil : ' + decodeFunction(type) + '(' + fieldName + '!)')
  }
  else {
    lines.push('if ' + fieldName + ' == nil { assertionFailure("field \'' + name + '\' is missing"); return nil }');
    lines.push('let ' + valueName + ': ' + typeString + '? = ' + decodeFunction(type) + '(' + fieldName + '!)')
    lines.push('if ' + valueName + ' == nil { assertionFailure("field \'' + name + '\' is not ' + typeString + '"); return nil }');
    lines.push('let ' + name + ': ' + typeString + ' = ' + valueName + '!');
  }

  lines.push('');

  return lines;
}

function makeReturn(struct: Struct) {
  var params = struct.varDecls.map(decl => decl.name + ': ' + decl.name);

  return 'return ' + struct.baseName + '(' + params.join(', ') + ')'
}

