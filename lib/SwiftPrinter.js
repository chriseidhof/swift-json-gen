//
// Several functions for generating Swift code based on the parsed AST.
//
var ast = require('./SwiftAst');
function makeFile(file, aliases, filename) {
    var lines = [];
    lines.push('//');
    lines.push('//  ' + filename);
    lines.push('//');
    lines.push('//  Auto generated by swift-json-gen on ' + new Date().toUTCString());
    lines.push('//');
    lines.push('');
    lines.push('import Foundation');
    lines.push('');
    var structs = ast.structs(file, aliases);
    structs.forEach(function (s) {
        lines = lines.concat(makeExtension(s));
        lines.push('');
    });
    return lines;
}
exports.makeFile = makeFile;
function makeExtension(struct) {
    var pre = [
        'extension ' + struct.baseName + ' {',
        '  static func decode' + decodeArguments(struct) + ' -> ' + struct.baseName + '? {',
        '    let _dict = json as? [String : AnyObject]',
        '    if _dict == nil { return nil }',
        '    let dict = _dict!',
        '',
    ];
    var post = [
        '  }',
        '}'
    ];
    var lines = pre;
    struct.varDecls.forEach(function (d) {
        var subs = makeField(d, struct.typeArguments).map(indent(4));
        lines = lines.concat(subs);
    });
    lines = lines.concat(indent(4)(makeReturn(struct)));
    lines = lines.concat(post);
    return lines.join('\n');
}
function decodeArguments(struct) {
    var parts = struct.typeArguments
        .map(function (t) { return 'decode' + t + ': AnyObject -> ' + t + '?'; });
    parts.push('json: AnyObject');
    for (var i = 1; i < parts.length; i++) {
        parts[i] = '_ ' + parts[i];
    }
    return parts.map(function (p) { return '(' + p + ')'; }).join('');
}
function indent(nr) {
    return function (s) {
        return s == '' ? s : Array(nr + 1).join(' ') + s;
    };
}
function isKnownType(type) {
    return type == 'AnyObject' || type == 'AnyJson';
}
function isCastType(type) {
    return type == 'JsonObject' || type == 'JsonArray';
}
function decodeFunction(type, decoders) {
    var args = type.genericArguments
        .map(function (a) { return decodeFunctionArgument(a, decoders); })
        .join('');
    if (isKnownType(type.baseName))
        return '{ $0 as ' + type.baseName + ' }';
    if (isCastType(type.baseName))
        return '{ $0 as? ' + type.baseName + ' }';
    if (decoders.indexOf(type.baseName) > -1)
        return 'decode' + type.baseName + args;
    return type.baseName + '.decode' + args;
}
function decodeFunctionArgument(type, decoders) {
    if (isKnownType(type.baseName))
        return '{ $0 as ' + type.baseName + ' }';
    if (isCastType(type.baseName))
        return '{ $0 as? ' + type.baseName + ' }';
    return '({ ' + decodeFunction(type, decoders) + '($0) })';
}
function typeToString(type) {
    if (type.genericArguments.length == 0)
        return type.baseName;
    if (type.baseName == 'Optional')
        return typeToString(type.genericArguments[0]) + '?';
    if (type.baseName == 'Array')
        return '[' + typeToString(type.genericArguments[0]) + ']';
    if (type.baseName == 'Dictionary')
        return '[' + typeToString(type.genericArguments[0]) + ' : ' + typeToString(type.genericArguments[1]) + ']';
    var args = type.genericArguments.map(typeToString).join(', ');
    return type.baseName + '<' + args + '>';
}
function makeField(field, structTypeArguments) {
    var name = field.name;
    var type = field.type;
    var fieldName = name + '_field';
    var valueName = name + '_value';
    var typeString = typeToString(type);
    var lines = [
        'let ' + fieldName + ': AnyObject? = dict["' + name + '"]',
    ];
    if (type.baseName == 'Optional') {
        lines.push('let ' + name + ': ' + typeString + ' = ' + fieldName + ' == nil ? nil : ' + decodeFunction(type, structTypeArguments) + '(' + fieldName + '!)');
    }
    else {
        lines.push('if ' + fieldName + ' == nil { assertionFailure("field \'' + name + '\' is missing"); return nil }');
        if (isKnownType(type.baseName)) {
            lines.push('let ' + name + ': ' + typeString + ' = ' + fieldName + '!');
        }
        else if (isCastType(type.baseName)) {
            lines.push('let ' + valueName + ': ' + typeString + '? = ' + fieldName + '! as? ' + typeString);
            lines.push('if ' + valueName + ' == nil { assertionFailure("field \'' + name + '\' is not ' + typeString + '"); return nil }');
            lines.push('let ' + name + ': ' + typeString + ' = ' + valueName + '!');
        }
        else {
            lines.push('let ' + valueName + ': ' + typeString + '? = ' + decodeFunction(type, structTypeArguments) + '(' + fieldName + '!)');
            lines.push('if ' + valueName + ' == nil { assertionFailure("field \'' + name + '\' is not ' + typeString + '"); return nil }');
            lines.push('let ' + name + ': ' + typeString + ' = ' + valueName + '!');
        }
    }
    lines.push('');
    return lines;
}
function makeReturn(struct) {
    var params = struct.varDecls.map(function (decl) { return decl.name + ': ' + decl.name; });
    return 'return ' + struct.baseName + '(' + params.join(', ') + ')';
}
