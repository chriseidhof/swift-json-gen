//
// Several functions for generating Swift code based on the parsed AST.
//

if (!String.prototype.startsWith) {
  Object.defineProperty(String.prototype, 'startsWith', {
    enumerable: false,
    configurable: false,
    writable: false,
    value: function (searchString, position) {
      position = position || 0;
      return this.lastIndexOf(searchString, position) === position;
    }
  });
}

if (!String.prototype.endsWith) {
  Object.defineProperty(String.prototype, 'endsWith', {
    value: function (searchString, position) {
      var subjectString = this.toString();
      if (position === undefined || position > subjectString.length) {
        position = subjectString.length;
      }
      position -= searchString.length;
      var lastIndex = subjectString.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    }
  });
}

function typeAliases(ast) {
  return ast.children()
    .filter(function (a) {
      return a.name() == 'typealias'
    }).map(function (t) {
      var name = t.fields().name().unquote();
      var type = t.attrs().filter(function(a) { return a[0] == 'type' })[1][1]

      return { name: name, type: type };
    });
}

exports.typeAliases = typeAliases;

function makeFile(file, typeAliases, filename) {
  var aliases = {}
  typeAliases.forEach(function (alias) {
    aliases[alias.name] = alias.type;
  });

  var lines = [];

  lines.push('//');
  lines.push('//  ' + filename);
  lines.push('//');
  lines.push('//  Auto generated by JsonGen on ' + new Date().toUTCString());
  lines.push('//');
  lines.push('');
  lines.push('import Foundation');
  lines.push('');

  var structs = file.children('struct_decl');
  structs.forEach(function (s) {
    var name = s.key(0);
    var decls = s.children('var_decl');

    lines = lines.concat(makeExtension(name, decls, aliases));
    lines.push('');
  });

  return lines;
}

exports.makeFile = makeFile;

function makeExtension(type, decls, typeAliases) {
  var pre = [
    'extension ' + type + ' {',
    '  static func decode(json : AnyObject) -> ' + type + '? {',
    '    let _dict = json as? [String : AnyObject]',
    '    if _dict == nil { return nil }',
    '    let dict = _dict!',
    '',
  ];
  var post = [
    '  }',
    '}'
  ];

  var lines = pre;

  var fields = decls.map(function (d) { return field(d, typeAliases) });
  fields.forEach(function (f) {
    var subs = makeField(f).map(indent(4));
    lines = lines.concat(subs);
  });

  lines = lines.concat(indent(4)(makeReturn(type, fields)));
  lines = lines.concat(post);

  return lines.join('\n');
}
function indent(nr) {
  return function (s) {
    return s == '' ? s :  Array(nr + 1).join(' ') + s;
  };
}

function field(decl, typeAliases) {
  var declaredType = decl.attr('type');
  var type = declaredType

  var isOptional = type.endsWith('?');
  var isArray = type.startsWith('[') && type.endsWith(']');
  var innerType = null;

  if (isOptional) {
    innerType = type.substring(0, type.length - 1).trim();
  }

  if (isArray) {
    innerType = type.substring(1, type.length - 1).trim();
  }

  if (typeAliases[innerType]) {
    innerType = typeAliases[innerType];
  }

  var isDictionary = false;
  var keyType = null;
  var valueType = null;

  var matches = innerType ? innerType.match(/\[(.*):(.*)\]/) : null;
  if (matches && matches.length == 3) {
    isOptional = false;
    isArray = false;
    innerType = null;

    isDictionary = true;
    keyType = matches[1].trim()
    valueType = matches[2].trim()
  }


  return {
    name: decl.key(0),
    type: declaredType,

    isOptional: isOptional,
    isArray: isArray,
    innerType: innerType,

    isDictionary: isDictionary,
    keyType: keyType,
    valueType: valueType,
  }
}

function makeField(field, typeAliases) {
  var name = field.name;

  var lines = [
    'let ' + name + '_field : AnyObject? = dict["' + name + '"]',
  ];

  if (field.isOptional && field.innerType == 'AnyObject') {
    lines.push('let ' + name + ': AnyObject? = ' + name + '_field')
  }
  else if (field.isOptional) {
    lines.push('let ' + name + ' = ' + name + '_field == nil ? nil : ' + field.innerType + '.decode(' + name +'_field!)')
  }
  else if (field.isArray && field.innerType == 'AnyObject') {
    lines.push('let ' + name + '_array = ' + name + '_field as? [AnyObject]')
    lines.push('if ' + name + '_array == nil { assertionFailure("field ' + name + ' missing or not an array"); return nil }')
    lines.push('let ' + name + ' = ' + name +'_array!')
  }
  else if (field.isDictionary) {
    lines.push('let ' + name + '_dictionary = ' + name + '_field as? ' + field.type)
    lines.push('if ' + name + '_dictionary == nil { assertionFailure("field ' + name + ' missing or not a dictionary"); return nil }')
    lines.push('let ' + name + ' = ' + name +'_dictionary!')
  }
  else if (field.isArray) {
    lines.push('let ' + name + '_array = ' + name + '_field as? [AnyObject]')
    lines.push('if ' + name + '_array == nil { assertionFailure("field ' + name + ' missing or not an array"); return nil }')
    lines.push('let ' + name + '_values = ' + name + '_array!.map(' + field.innerType + '.decode)')
    lines.push('if ' + name + '_values.filter({ $0 == nil }).count > 0 { return nil }')
    lines.push('let ' + name + ' = ' + name +'_values.map({ $0! })')
  }
  else if (field.innerType == 'AnyObject') {
    lines.push('if ' + name + '_field == nil { assertionFailure("field ' + name + ' missing"); return nil }')
    lines.push('let ' + name + ': AnyObject = ' + name + '_field!')
  }
  else {
    lines.push('if ' + name + '_field == nil { assertionFailure("field ' + name + ' missing"); return nil }')
    lines.push('let ' + name + '_optional = ' + field.type + '.decode(' + name +'_field!)')
    lines.push('if ' + name + '_optional == nil { assertionFailure("field ' + name + ' not a ' + field.type + '"); return nil }')
    lines.push('let ' + name + ' = ' + name + '_optional!')
  }

  lines.push('');

  return lines;
}

function makeReturn(name, fields) {
  var params = fields.map(function (field) {
    return field.name + ': ' + field.name;
  });

  return 'return ' + name + '(' + params.join(', ') + ')'
}

