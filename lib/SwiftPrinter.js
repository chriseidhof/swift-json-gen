//
// Several functions for generating Swift code based on the parsed AST.
//

if (!String.prototype.startsWith) {
  Object.defineProperty(String.prototype, 'startsWith', {
    enumerable: false,
    configurable: false,
    writable: false,
    value: function (searchString, position) {
      position = position || 0;
      return this.lastIndexOf(searchString, position) === position;
    }
  });
}

if (!String.prototype.endsWith) {
  Object.defineProperty(String.prototype, 'endsWith', {
    value: function (searchString, position) {
      var subjectString = this.toString();
      if (position === undefined || position > subjectString.length) {
        position = subjectString.length;
      }
      position -= searchString.length;
      var lastIndex = subjectString.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    }
  });
}

function makeFile(file, filename) {
  var lines = [];

  lines.push('//');
  lines.push('//  ' + filename);
  lines.push('//');
  lines.push('//  Auto generated by JsonGen on ' + new Date().toUTCString());
  lines.push('//');
  lines.push('');
  lines.push('import Foundation');
  lines.push('');

  var structs = file.children('struct_decl');
  structs.forEach(function (s) {
    var name = s.key(0);
    var decls = s.children('var_decl');

    lines = lines.concat(makeExtension(name, decls));
    lines.push('');
  });

  return lines;
}

exports.makeFile = makeFile;

function makeExtension(type, decls) {
  var pre = [
    'extension ' + type + ' {',
    '  static func decode(json : AnyObject) -> ' + type + '? {',
    '    let _dict = json as? [String : AnyObject]',
    '    if _dict == nil { return nil }',
    '    let dict = _dict!',
    '',
  ];
  var post = [
    '  }',
    '}'
  ];

  var lines = pre;

  var fields = decls.map(field);
  fields.forEach(function (f) {
    var subs = makeField(f).map(indent(4));
    lines = lines.concat(subs);
  });

  lines = lines.concat(indent(4)(makeReturn(type, fields)));
  lines = lines.concat(post);

  return lines.join('\n');
}
function indent(nr) {
  return function (s) {
    return Array(nr + 1).join(' ') + s;
  };
}

function field(decl) {
  var type = decl.attr('type');
  var isOptional = type.endsWith('?');
  var isArray = type.startsWith('[') && type.endsWith(']');
  var innerType = type;

  if (isOptional) {
    innerType = type.substring(0, type.length - 1);
  }

  if (isArray) {
    innerType = type.substring(1, type.length - 1);
  }

  return {
    name: decl.key(0),
    type: type,
    isOptional: isOptional,
    isArray: isArray,
    innerType: innerType,
  }
}

function makeField(field) {
  var name = field.name;

  var lines = [
    'let ' + name + '_field : AnyObject? = dict["' + name + '"]',
  ];

  if (field.isOptional) {
    lines.push('let ' + name + ' = ' + name + '_field == nil ? nil : ' + field.innerType + '.decode(' + name +'_field!)')
  }
  else if (field.isArray) {
    lines.push('let ' + name + '_array = ' + name + '_field as? [AnyObject]')
    lines.push('if ' + name + '_array == nil { assertionFailure("field ' + name + ' missing or not an array"); return nil }')
    lines.push('let ' + name + '_values = ' + name + '_array!.map(' + field.innerType + '.decode)')
    lines.push('if ' + name + '_values.filter({ $0 == nil }).count > 0 { return nil }')
    lines.push('let ' + name + ' = ' + name +'_values.map({ $0! })')
  }
  else {
    lines.push('if ' + name + '_field == nil { assertionFailure("field ' + name + ' missing"); return nil }')
    lines.push('let ' + name + '_optional = ' + field.innerType + '.decode(' + name +'_field!)')
    lines.push('if ' + name + '_optional == nil { assertionFailure("field ' + name + ' not a ' + field.innerType + '"); return nil }')
    lines.push('let ' + name + ' = ' + name + '_optional!')
  }

  lines.push('');

  return lines;
}

function makeReturn(name, fields) {
  var params = fields.map(function (field) {
    return field.name + ': ' + field.name;
  });

  return 'return ' + name + '(' + params.join(', ') + ')'
}

